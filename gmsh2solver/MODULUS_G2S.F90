module DS_Gmsh2Solver
    

    INTERFACE ENLARGE_AR
        MODULE PROCEDURE I_ENLARGE_AR,R_ENLARGE_AR,NODE_ENLARGE_AR,ELEMENT_ENLARGE_AR,BCGROUP_ENLARGE_AR,&
                        FACE_TYDEF_ENLARGE_AR,EDGE_TYDEF_ENLARGE_AR,BCTYPE_ENLARGE_AR,R_ENLARGE_AR2D
    END INTERFACE    
    
    INTEGER::NLAYER=1
    INTEGER,ALLOCATABLE::SUBLAYER(:)
    LOGICAL::ISGENLAYER=.FALSE.
    INTEGER::NOPOPUP=1
    TYPE EDGE_TYDEF
        LOGICAL::ISINI=.FALSE.
        INTEGER::V(2)=0
        INTEGER::HKEY=-1
        CHARACTER(64)::CKEY=""
        INTEGER::NEL=0
        INTEGER,ALLOCATABLE::ELEMENT(:),SUBID(:) !SUBID IS INDEX WHICH EDGE OF THE ELEMENT IS THE EDGE
    ENDTYPE
    TYPE(EDGE_TYDEF),ALLOCATABLE::EDGE(:)
    TYPE FACE_TYDEF
        LOGICAL::ISINI=.FALSE.
        INTEGER::SHAPE=3
        INTEGER::V(4)=0,EDGE(4)=0
        INTEGER::HKEY=-1
        CHARACTER(64)::CKEY="" 		
        INTEGER::ISTRISURFACE=0 !<-1 与face反向
        REAL(8)::UNORMAL(3)=0.D0		
        INTEGER::NEL=0
        INTEGER,ALLOCATABLE::ELEMENT(:),SUBID(:) !SUBID IS INDEX WHICH FACE OF THE ELEMENT IS THE FACE       
    ENDTYPE
    TYPE(FACE_TYDEF),ALLOCATABLE::FACE(:)    
    INTEGER::NEDGE=0,NFACE=0,MAXNEDGE=10000,MAXNFACE=10000
    
	type node_type
		integer::inode=0,NEL=0
		real(8)::xy(3)=0
		INTEGER::ISDEAD=0
        INTEGER::N1=0 !FOR TEMPORARY USE ONLY.
        INTEGER,ALLOCATABLE::ELEMENT(:)
	end type
	type(node_type),allocatable::node(:)
	integer::nnode=0,TNNODE=0,gnnode=0
	integer,allocatable::Noutputorder(:),g2n(:)

	type element_type
        integer::et=-1
		integer::ntag=0
		integer,allocatable::tag(:)
		!number-of-tags
		!gives the number of integer tags that follow for the n-th element. 
		!By default, the first tag is the number of the physical entity to which the element belongs;
		!the second is the number of the elementary geometrical entity to which the element belongs; 
		!the third is the number of mesh partitions to which the element belongs, 
		!followed by the partition ids (negative partition ids indicate ghost cells). A zero tag is equivalent to no tag. 
        integer::ilayer=1
		integer::nnode=0,nedge=0,nface=0
		integer,allocatable::node(:)
        INTEGER,ALLOCATABLE::EDGE(:),FACE(:)
        INTEGER::TOPONODE(2)=0 !只对由高次单元生成一次对wellbore类单元有用，当其他面元或体元为高次单元时，因wellbore类单元目前只有2节点的一次单元，所以对高次线单元进行了分解，
        REAL(8)::BBOX(2,3)=0.D0 !MIN,MAX OF X,Y AND Z
        REAL(8)::CENT(3)=0.D0
        !toponode记录当前单元对应的高次单元的端节点，以便进行后面的拓扑邻接分析。
        
    !CONTAINS
    !    PROCEDURE::GET_EDGE=>SET_ELEMENT_EDGE
    !    PROCEDURE::GET_FACE=>SET_ELEMENT_FACE
	end type
	type(element_type),allocatable::element(:)
	integer::nel=0
	
	
	type physicalGroup_type
		integer::isini=0,SF=0,istopo=0 !对于由高次单元生成的一次Wellbore类单元，istopo==1,要输出对应的toponode节点。 
		integer::ndim,COUPLESET=0 !COUPLESET>0 AND <>itself，表此单元组的单元与physicalgroup(COUPLESET)的单元相同。 by default it was set to be itself
		logical::ismodel=.FALSE.,ISMASTER=.TRUE. !phgpnum(:) OUPLESET>0 AND <>itself, ismaster=.false. then let elemnt=coupleset.element
        integer::ET_GMSH=0,icowmat=0 !icowmat>0时，表此防渗墙为材料分段防渗墙 
		character(32)::name=''
		integer::nel=0
		integer,allocatable::element(:),COWMAT(:)
		integer::mat(50)=0
		character(32)::ET="ELT_BC_OR_LOAD"
		INTEGER::LAYERGROUP(50)=0	
        INTEGER,ALLOCATABLE::TRISURFACE(:),QUASURFACE(:),TRINODEG2L(:),TRINODEL2G(:) !global to local
        INTEGER::NTRISURFACE=0,NQUASURFACE=0,NTRINODEL2G=0
        REAL(8)::PROPERTY(3)=0.D0
	end type
	integer,parameter::maxphgp=10100
	type(physicalGroup_type)::physicalgroup(maxphgp)
	integer,allocatable::phgpnum(:)
	integer::nphgp=0
	
	type et_type
		integer::nnode=0,nedge=0,nface=0		
		character(512)::description
		integer,allocatable::edge(:,:),face(:,:),FaceEdge(:,:)
		!edge(2,nedge),
		!face: use node index to represent face. face(0:4,nface),face(0,:)==3,triangular face,==4, quadrilateral face
		!FaceEdge: use edge index to represent face. FaceEdge(0:4,nface),FaceEdge(0,:)==3,triangular face, ==4, quadrilateral face
		real(8),allocatable::weight(:,:) !分布单元荷载各节点分布系数, weight(:,1) 平面均布荷载；weight(:,2) 平面三角形荷载;weight(:,3) 轴对称均布荷载；weight(:,4) 轴对称三角形荷载，
													!目前只能处理平面应变的两种情况。
	end type
	type(et_type)::elttype(100)
	
	type bcgroup_type
		integer::group,ISFIELD=0,ISINPUT=0
		integer::ndim=0 !=0,point load; =1,line load; =2, planar load; =3,volume load;
		integer::dof
		integer::sf=0
		real(8)::value=0  !当输入seepageface时，value=1,2,3 分别表示节点的水头值等于坐标x,y,z.
		integer::n1=0,n2=0 !for spgface output
        real(8)::LFC(4)=0.d0 !FIELD=AX+BY+CY+D LFC()=[A,B,C,D]
        integer::ISWELLCONDITION=0 !是否为井的边界，或出溢面
        integer::spg_isdual=0
    CONTAINS
        PROCEDURE::GETVALUE=>LINEARFILEDCAL
	end type
	type(bcgroup_type),allocatable::elt_bc(:),elt_load(:),elt_spgface(:)
	integer::nelt_bc,nelt_load,nelt_spgface
	
	type bc_tydef
		integer::node,dof	!when body force is input, node equels to element	
		integer::sf=0 !step function for this load
		integer::isdead=0 !for seepage face iterative, =1,the condition is no longer on work. 
		real(8)::value=0
        integer::spg_isdual=0
	end type
	type(bc_tydef),allocatable::nodalLoad(:),nodalBC(:),spgface(:),Wellhead(:),WellSpgface(:)
	integer::nnodalLoad=0,maxnnodalLoad=1000
	integer::nnodalBC=0,maxnnodalBC=1000
	integer::nspgface=0,maxnspgface=1000
    integer::nwellhead=0,maxnwellhead=0
    integer::nwellspgface=0,maxnwellspgface=0
    
    type wsp_typdef
        integer::Group,chgroup,spgroup !chgroup, characteristic point.
        integer::xdirection=1
        integer::nnode=0,nchnode=0
        integer,allocatable::node(:)
		integer,allocatable::chnode(:)
    end type
    type(wsp_typdef),allocatable::wsp(:)
    integer::nwsp=0
    
    type out_data_typdef
        integer::Group
        integer::SPGroup !Startpoint Group,这个Group只有一个点。
		integer::order=0
        integer::issumq=0 !/=0, 表示仅输出各节点的流量和。
        integer::isstat=0 ! ISSTAT>0,输出此数据集内各变量的统计量，包括[sum,max,min,mean,median,mad,std,kurtosis,skewness]
        integer::nnode=0
        integer,allocatable::node(:)        
    end type
    type(out_data_typdef),allocatable::DataPoint(:)
    integer::NDataPoint=0
	
	TYPE OFF_MESH_TYPDEF
		CHARACTER(512)::FILE=''
		INTEGER::PGPID=0
		INTEGER::NNODE=0,NEL=0,NEDGE=0
		integer,ALLOCATABLE::ELEMENT(:)
	ENDTYPE
	integer,parameter::MAXOFF=100
	integer,allocatable::OFFINDEX(:)
	integer::NOFF=0,NOFFNODE=0,NOFFFACE=0
	TYPE(OFF_MESH_TYPDEF)::OFFMESH(MAXOFF)
	REAL(8),ALLOCATABLE::OFFNODE(:,:)
	INTEGER,ALLOCATABLE::OFFFACE(:,:)
	REAL(8)::XYZTOL=1.D-4
	
	integer,allocatable::modelgroup(:)
	integer::nmodelgroup=0
		
	character(512)::resultfile,title,INCLUDEFILE(0:100),COPYFILE(100),FILEPATH,meshstructurefile
	INTEGER::NINCLUDEFILE=0,NCOPYFILE=0
		
	integer,allocatable::adjL(:,:)
	integer::maxadj=100
	
	integer::modeldimension=2,ISREORDER=1
    integer::IsoutMS=0
    REAL(8),ALLOCATABLE::ELEVATION(:,:)
    
    !INTEGER::EDGE
    
    TYPE TRISURFACE_TYDEF
        INTEGER::NV,NF
        INTEGER,ALLOCATABLE::V(:),TRI(:)
    ENDTYPE
    TYPE(TRISURFACE_TYDEF),ALLOCATABLE::TRISURFACE(:)
    INTEGER::NTRISURFACE
    INTEGER::ISGENTRISURFACE=0,ISGEO=0,ISSTL=0,ISOFF=0
    
    TYPE WELLBORE_TYDEF
        INTEGER::IGP=0,WELLNODE=0,NWELLBORESEG=-1,BCTYPE=0,NWNODE=0,PIPEFLOW=-1,SPHERICALFLOW=0,NSEMI_SF=0
        INTEGER::NSPG_FACE=0,MAT=0,NQNODE=0
        REAL(8)::R,VALUE=0.D0
        INTEGER,ALLOCATABLE::SEMI_SF_IPG(:),SPG_FACE(:),QNODE(:,:) !,SINK_NODE_SPG_FACE(:)
        !QNODE,统计各井流量时该井所属的节点，包括井口节点及出溢面上的所有节点。
        REAL(8),ALLOCATABLE::DIR_VECTOR(:,:)
        
    CONTAINS
        PROCEDURE::INITIALIZE=>WELLBORE_INITIALIZE
        PROCEDURE::OUTQNODE=>WELLBORE_OUTPUTQNODE
    ENDTYPE
    TYPE(WELLBORE_TYDEF),ALLOCATABLE::WELLBORE(:)
    INTEGER::NWELLBORE=0,wellh2lmethod=0
    
    TYPE COWMAT_TYDEF
        INTEGER::ID=0,NMAT=0
        REAL(8),ALLOCATABLE::Z(:)
        INTEGER,ALLOCATABLE::MAT(:)
    ENDTYPE
    TYPE(COWMAT_TYDEF),ALLOCATABLE::COWMAT(:)
    INTEGER::NCOWMAT=0
    CONTAINS
    
    REAL(8) FUNCTION LINEARFILEDCAL(BCG,X,Y,Z)
        IMPLICIT NONE
        CLASS(bcgroup_type),INTENT(IN)::BCG
        REAL(8),INTENT(IN),OPTIONAL::X,Y,Z
        REAL(8)::X1=0.D0,Y1=0.D0,Z1=0.D0
        
        IF(BCG.ISFIELD==0) THEN
            LINEARFILEDCAL=BCG.VALUE
            IF(BCG.DOF==4) THEN
                IF(ABS(BCG.VALUE+999.0D0)<1.D-7) THEN
                    IF(modeldimension==3) THEN
                        LINEARFILEDCAL=Z
                    ELSE
                        LINEARFILEDCAL=Y
                    ENDIF
                ENDIF
            ENDIF
        ELSE
            IF(PRESENT(X)) THEN
                X1=X 
            ELSE
                X1=0.D0
            ENDIF
            IF(PRESENT(Y)) THEN
                Y1=Y 
            ELSE
                Y1=0.D0
            ENDIF
            IF(PRESENT(Z)) THEN
                Z1=Z 
            ELSE
                Z1=0.D0
            ENDIF       
            
            LINEARFILEDCAL=BCG.LFC(1)*X1+BCG.LFC(2)*Y1+BCG.LFC(3)*Z1+BCG.LFC(4)
        ENDIF
    ENDFUNCTION
    
    SUBROUTINE I_ENLARGE_AR(AVAL,DSTEP)
        INTEGER,ALLOCATABLE,INTENT(INOUT)::AVAL(:)
        INTEGER,INTENT(IN)::DSTEP
        INTEGER,ALLOCATABLE::VAL1(:)
        INTEGER::LB1=0,UB1=0
    
        LB1=LBOUND(AVAL,DIM=1);UB1=UBOUND(AVAL,DIM=1)
        ALLOCATE(VAL1,SOURCE=AVAL)
        DEALLOCATE(AVAL)
        ALLOCATE(AVAL(LB1:UB1+DSTEP))
        AVAL(LB1:UB1)=VAL1
        !AVAL(UB1+1:UB1+10)=0
        DEALLOCATE(VAL1)
    END SUBROUTINE

    SUBROUTINE R_ENLARGE_AR(AVAL,DSTEP)
        REAL(8),ALLOCATABLE,INTENT(INOUT)::AVAL(:)
        INTEGER,INTENT(IN)::DSTEP
        REAL(8),ALLOCATABLE::VAL1(:)
        INTEGER::LB1=0,UB1=0
    
        LB1=LBOUND(AVAL,DIM=1);UB1=UBOUND(AVAL,DIM=1)
        ALLOCATE(VAL1,SOURCE=AVAL)
        DEALLOCATE(AVAL)
        ALLOCATE(AVAL(LB1:UB1+DSTEP))
        AVAL(LB1:UB1)=VAL1
        !AVAL(UB1+1:UB1+10)=0
        DEALLOCATE(VAL1)
    END SUBROUTINE
    SUBROUTINE R_ENLARGE_AR2D(AVAL,DSTEP)
        REAL(8),ALLOCATABLE,INTENT(INOUT)::AVAL(:,:)
        INTEGER,INTENT(IN)::DSTEP
        REAL(8),ALLOCATABLE::VAL1(:,:)
        INTEGER::LB1=0,UB1=0,I,LB2,UB2
    
        LB1=LBOUND(AVAL,DIM=2);UB1=UBOUND(AVAL,DIM=2)
        ALLOCATE(VAL1,SOURCE=AVAL)
        DEALLOCATE(AVAL)
        LB2=LBOUND(AVAL,DIM=1);UB2=UBOUND(AVAL,DIM=1)
        ALLOCATE(AVAL(LB2:UB2,LB1:UB1+DSTEP))
        DO I=LB2,UB2
            AVAL(I,LB1:UB1)=VAL1(I,LB1:UB1)
        ENDDO
        !AVAL(UB1+1:UB1+10)=0
        DEALLOCATE(VAL1)
    END SUBROUTINE    
    SUBROUTINE FACE_TYDEF_ENLARGE_AR(AVAL,DSTEP)
        TYPE(FACE_TYDEF),ALLOCATABLE,INTENT(INOUT)::AVAL(:)
        INTEGER,INTENT(IN)::DSTEP
        TYPE(FACE_TYDEF),ALLOCATABLE::VAL1(:)
        INTEGER::LB1=0,UB1=0
    
        LB1=LBOUND(AVAL,DIM=1);UB1=UBOUND(AVAL,DIM=1)
        ALLOCATE(VAL1,SOURCE=AVAL)
        DEALLOCATE(AVAL)
        ALLOCATE(AVAL(LB1:UB1+DSTEP))
        AVAL(LB1:UB1)=VAL1
        !AVAL(UB1+1:UB1+10)=0
        DEALLOCATE(VAL1)
    END SUBROUTINE 
    SUBROUTINE EDGE_TYDEF_ENLARGE_AR(AVAL,DSTEP)
        TYPE(EDGE_TYDEF),ALLOCATABLE,INTENT(INOUT)::AVAL(:)
        INTEGER,INTENT(IN)::DSTEP
        TYPE(EDGE_TYDEF),ALLOCATABLE::VAL1(:)
        INTEGER::LB1=0,UB1=0
    
        LB1=LBOUND(AVAL,DIM=1);UB1=UBOUND(AVAL,DIM=1)
        ALLOCATE(VAL1,SOURCE=AVAL)
        DEALLOCATE(AVAL)
        ALLOCATE(AVAL(LB1:UB1+DSTEP))
        AVAL(LB1:UB1)=VAL1
        !AVAL(UB1+1:UB1+10)=0
        DEALLOCATE(VAL1)
    END SUBROUTINE
    SUBROUTINE NODE_ENLARGE_AR(AVAL,DSTEP)
        TYPE(node_type),ALLOCATABLE,INTENT(INOUT)::AVAL(:)
        INTEGER,INTENT(IN)::DSTEP
        TYPE(node_type),ALLOCATABLE::VAL1(:)
        INTEGER::LB1=0,UB1=0
    
        LB1=LBOUND(AVAL,DIM=1);UB1=UBOUND(AVAL,DIM=1)
        ALLOCATE(VAL1,SOURCE=AVAL)
        DEALLOCATE(AVAL)
        ALLOCATE(AVAL(LB1:UB1+DSTEP))
        AVAL(LB1:UB1)=VAL1
        !AVAL(UB1+1:UB1+10)=0
        DEALLOCATE(VAL1)
    END SUBROUTINE   	
    SUBROUTINE ELEMENT_ENLARGE_AR(AVAL,DSTEP)
        TYPE(element_type),ALLOCATABLE,INTENT(INOUT)::AVAL(:)
        INTEGER,INTENT(IN)::DSTEP
        TYPE(element_type),ALLOCATABLE::VAL1(:)
        INTEGER::LB1=0,UB1=0
    
        LB1=LBOUND(AVAL,DIM=1);UB1=UBOUND(AVAL,DIM=1)
        ALLOCATE(VAL1,SOURCE=AVAL)
        DEALLOCATE(AVAL)
        ALLOCATE(AVAL(LB1:UB1+DSTEP))
        AVAL(LB1:UB1)=VAL1
        !AVAL(UB1+1:UB1+10)=0
        DEALLOCATE(VAL1)
    END SUBROUTINE
    SUBROUTINE BCGROUP_ENLARGE_AR(AVAL,DSTEP)
        TYPE(bcgroup_type),ALLOCATABLE,INTENT(INOUT)::AVAL(:)
        INTEGER,INTENT(IN)::DSTEP
        TYPE(bcgroup_type),ALLOCATABLE::VAL1(:)
        INTEGER::LB1=0,UB1=0,ERR
    
        LB1=LBOUND(AVAL,DIM=1);UB1=UBOUND(AVAL,DIM=1)
        ALLOCATE(VAL1,SOURCE=AVAL,STAT=ERR)
        DEALLOCATE(AVAL,STAT=ERR)
        ALLOCATE(AVAL(LB1:UB1+DSTEP),STAT=ERR)
        AVAL(LB1:UB1)=VAL1
        !AVAL(UB1+1:UB1+10)=0
        DEALLOCATE(VAL1,STAT=ERR)
    END SUBROUTINE
    SUBROUTINE BCTYPE_ENLARGE_AR(AVAL,DSTEP,UBAVAL)
        TYPE(bc_tydef),ALLOCATABLE,INTENT(INOUT)::AVAL(:)
        INTEGER,INTENT(IN)::DSTEP
        INTEGER,INTENT(IN OUT),OPTIONAL::UBAVAL
        TYPE(bc_tydef),ALLOCATABLE::VAL1(:)
        
        INTEGER::LB1=0,UB1=0,ERR
    
        LB1=LBOUND(AVAL,DIM=1);UB1=UBOUND(AVAL,DIM=1)
    
        ALLOCATE(VAL1,SOURCE=AVAL,STAT=ERR)
        IF(ALLOCATED(AVAL)) DEALLOCATE(AVAL)
        ALLOCATE(AVAL(LB1:UB1+DSTEP))
        AVAL(LB1:UB1)=VAL1
        IF(PRESENT(UBAVAL)) UBAVAL=UB1+DSTEP
        !AVAL(UB1+1:UB1+10)=0
        IF(ALLOCATED(VAL1)) DEALLOCATE(VAL1)
    END SUBROUTINE   
    
    SUBROUTINE WELLBORE_INITIALIZE(SELF)
        CLASS(WELLBORE_TYDEF)::SELF
        INTEGER::I,J,K,N1,N2,N3,N4,INODE1,IEL1,II1,N5,NEL1,imethod1
        INTEGER::NODE1(10),ELT1(10)
        INTEGER,ALLOCATABLE::ISWBE1(:),IELT1(:)
        INTEGER,ALLOCATABLE::IA1(:)
        CHARACTER(16),PARAMETER::CAR1(3)=["PIPE2","WELLBORE","WELLBORE_SPGFACE"]
        
        !generate four-noded well element
        ! 1 +-----------+ 2
        !   |           |
        ! 4 +           + 3
        !5-------------------6 !TOPONODE
        ! Node 1 and 2: Line element simulating well flow along the well.
        ! Element 1-4 and 2-3 : virtual branch element 
        
        
        
        NODE.N1=0
        N3=2+SELF.NSPG_FACE
        ALLOCATE(IA1(N3))
        IF(SELF.NSPG_FACE>0) THEN
            IA1=[SELF.IGP,SELF.PIPEFLOW,SELF.SPG_FACE]
        ELSE
            IA1=[SELF.IGP,SELF.PIPEFLOW]
        ENDIF

        DO IJ1=1,N3
            
            N1=IA1(IJ1)
            
            IF(N1<1) CYCLE
            
            IF(IJ1==1) THEN
                PHYSICALGROUP(N1).ET="WELLBORE"
            ELSEIF(IJ1==2) THEN
                PHYSICALGROUP(N1).ET="PIPE2"
            ELSE
                PHYSICALGROUP(N1).ET="WELLBORE_SPGFACE"
            ENDIF
            
            PHYSICALGROUP(N1).ISMODEL=.TRUE.
            PHYSICALGROUP(N1).MAT(1)=SELF.MAT
            
            IF(PHYSICALGROUP(N1).MAT(1)==0.AND.IA1(1)>0) THEN
                PHYSICALGROUP(N1).MAT(1)=PHYSICALGROUP(IA1(1)).MAT(1)  !!!!          
            ENDIF
            IF(PHYSICALGROUP(N1).MAT(1)==0.AND.IA1(2)>0) THEN
                PHYSICALGROUP(N1).MAT(1)=PHYSICALGROUP(IA1(2)).MAT(1)            
            ENDIF            
            IF(PHYSICALGROUP(N1).MAT(1)==0) THEN
                PRINT *,'PLEASE SIGN A MATID TO PHYSICALGROUP(N1) THROUGH "GROUPPARAMETER". N1=',N1
                STOP
            ENDIF
            
            N5=ELEMENT(PHYSICALGROUP(N1).ELEMENT(1)).NNODE-1
            !对于高次线单元，因wellbore类单元只有2节点的线单元，转化为2节点的线单元
            N2=0;imethod1=wellh2lmethod !=0,把高次单元生成多个一次单元；=1,去除内部节点，只利用端节点生成1个一次单元
            IF(N5>1) THEN
                if(imethod1==0) then
                    CALL ENLARGE_AR(PHYSICALGROUP(N1).ELEMENT,PHYSICALGROUP(N1).NEL*(N5-1)) 
                    CALL ENLARGE_AR(ELEMENT,PHYSICALGROUP(N1).NEL*(N5-1))
                    IF(ALLOCATED(IELT1)) DEALLOCATE(IELT1)
                    ALLOCATE(IELT1(PHYSICALGROUP(N1).NEL*N5))
                endif
                DO J=1,PHYSICALGROUP(N1).NEL
                    IEL1=PHYSICALGROUP(N1).ELEMENT(J)
                    NODE1(1:ELEMENT(IEL1).NNODE)=ELEMENT(IEL1).NODE([1,3:ELEMENT(IEL1).NNODE,2]) 
                    ELEMENT(IEL1).NNODE=2
                    ELEMENT(IEL1).ET=1
                    IF(IMETHOD1==0) THEN
                        !对于由高次线单元分解形成的一次单元，因后面单元拓扑邻接分析时，只分析高次单元的边(即忽略中间节点)，导致由含内部节点的单元的边不体现，
                        !为解决此问题，输出对应高次单元的端节点，利用此端节点进行拓扑分析。
                        !略显麻烦。
                        
                        ELEMENT(IEL1).TOPONODE=ELEMENT(IEL1).NODE(1:2) 
                        DO K=1,N5
                            IF(K<2) THEN
                                N3=IEL1 !本身，ELEMENT
                            ELSE
                                NEL=NEL+1 !新单元
                                N3=NEL
                                ELEMENT(N3)=ELEMENT(IEL1)
                            ENDIF
                            N2=N2+1
                            IELT1(N2)=N3
                            ELEMENT(N3).NODE=NODE1(K:K+1)
                        
                        ENDDO
                    ELSE
                        ELEMENT(IEL1).NODE=ELEMENT(IEL1).NODE(1:2)
                    ENDIF
                    
                ENDDO
                IF(IMETHOD1==0) THEN
                    PHYSICALGROUP(N1).NEL=PHYSICALGROUP(N1).NEL*N5
                    PHYSICALGROUP(N1).ELEMENT=IELT1
                    PHYSICALGROUP(N1).istopo=1
                ENDIF
                PHYSICALGROUP(N1).ET_GMSH=1
                
                
            ENDIF
            
            
            DO J=1,PHYSICALGROUP(N1).NEL
            
                IEL1=PHYSICALGROUP(N1).ELEMENT(J)
            
                DO K=1,ELEMENT(IEL1).NNODE
                    INNODE1=ELEMENT(IEL1).NODE(K)
                    IF(NODE(INNODE1).N1==0) THEN
                        NNODE=NNODE+1
                        NODE(INNODE1).N1=NNODE
                        IF(NNODE>UBOUND(NODE,DIM=1)) THEN
                            CALL ENLARGE_AR(NODE,1000)       
                        ENDIF
                        NODE(NNODE)=NODE(INNODE1)
                        NODE(NNODE).N1=INNODE1
                    ENDIF                
                ENDDO
            
                ELEMENT(IEL1).NODE=NODE(ELEMENT(IEL1).NODE).N1
                
                IF(IJ1==2) THEN
                    PHYSICALGROUP(N1).ET_GMSH=1
                    
                ELSE
                    !滤管井单元,井流出溢面单元              
                    ELEMENT(IEL1).NNODE=2*ELEMENT(IEL1).NNODE
                    NODE1(1:ELEMENT(IEL1).NNODE)=[ELEMENT(IEL1).NODE,NODE(ELEMENT(IEL1).NODE).N1]
                    DEALLOCATE(ELEMENT(IEL1).NODE)
                    N2=ELEMENT(IEL1).NNODE/2
                    ALLOCATE(ELEMENT(IEL1).NODE,SOURCE=NODE1([1:N2,ELEMENT(IEL1).NNODE:N2+1:-1]))
                    PHYSICALGROUP(N1).ET_GMSH=3                
                ENDIF
                
                !SELECT CASE(IJ1)
                !CASE(1)                   
                ! !滤管井单元           
                !    ELEMENT(IEL1).NNODE=2*ELEMENT(IEL1).NNODE
                !    NODE1(1:ELEMENT(IEL1).NNODE)=[ELEMENT(IEL1).NODE,NODE(ELEMENT(IEL1).NODE).N1]
                !    DEALLOCATE(ELEMENT(IEL1).NODE)
                !    N2=ELEMENT(IEL1).NNODE/2
                !    ALLOCATE(ELEMENT(IEL1).NODE,SOURCE=NODE1([1:N2,ELEMENT(IEL1).NNODE:N2+1:-1]))
                !    PHYSICALGROUP(N1).ET_GMSH=3   
                !CASE(2) !管流单元
                !    !NOTHING TO DO
                !    PHYSICALGROUP(N1).ET_GMSH=1
                !CASE DEFAULT !井流出溢面单元                    
                !    ! :>>>>>>>>>>>>>>>>>>>>>>:
                !    ! 1...........2>>>>>>>>>>5(SinkNode(滤管最上面的边界节点))   (井壁侧)  !实际为1-4和2-3两个线单元，第5个节点只是为统计井流量用。
                !    ! |           |
                !    ! 4           3                                                
                !    ELEMENT(IEL1).NNODE=2*ELEMENT(IEL1).NNODE+1
                !    N4=ELEMENT(PHYSICALGROUP(SELF.SINK_NODE_SPG_FACE(IJ1-2)).ELEMENT(1)).NODE(1) !此集只含一个单节点的单元
                !    N4=NODE(N4).N1
                !    NODE1(1:ELEMENT(IEL1).NNODE)=[ELEMENT(IEL1).NODE,NODE(ELEMENT(IEL1).NODE).N1,N4]
                !    DEALLOCATE(ELEMENT(IEL1).NODE)
                !    N2=(ELEMENT(IEL1).NNODE-1)/2
                !    ALLOCATE(ELEMENT(IEL1).NODE,SOURCE=NODE1([1:N2,ELEMENT(IEL1).NNODE-1:N2+1:-1,ELEMENT(IEL1).NNODE]))
                !    PHYSICALGROUP(N1).ET_GMSH=3
                !ENDSELECT
            ENDDO
        
        ENDDO

     
        
        IF(SELF.SPHERICALFLOW>0) THEN
            N2=SELF.SPHERICALFLOW
            PHYSICALGROUP(N2).ISMODEL=.TRUE.
            IF(PHYSICALGROUP(N2).MAT(1)==0.AND.IA1(1)>0) THEN
                PHYSICALGROUP(N2).MAT=PHYSICALGROUP(IA1(1)).MAT
            ENDIF
            IF(PHYSICALGROUP(N2).MAT(1)==0.AND.IA1(2)>0) THEN
                PHYSICALGROUP(N2).MAT=PHYSICALGROUP(IA1(2)).MAT
            ENDIF  
            IF(PHYSICALGROUP(N2).MAT(1)==0) THEN
                PRINT *,'PLEASE SIGN A MATID TO PHYSICALGROUP(N2) THROUGH "GROUPPARAMETER". N2=',N2
                STOP
            ENDIF            
            PHYSICALGROUP(N2).ET="SPHFLOW"
            PHYSICALGROUP(N2).ET_GMSH=1
            DO I=1,PHYSICALGROUP(N2).NEL
                IEL1=PHYSICALGROUP(N2).ELEMENT(I)
                ELEMENT(IEL1).NNODE=2
                IF(NODE(ELEMENT(IEL1).NODE(1)).N1==0) THEN
                    STOP "GHOST NODE N1 SHOULD BE >0. Error in sub WELLBORE_INITIALIZE."
                ENDIF
                NODE1(1:ELEMENT(IEL1).NNODE)=[NODE(ELEMENT(IEL1).NODE).N1,ELEMENT(IEL1).NODE]
                DEALLOCATE(ELEMENT(IEL1).NODE)
                ALLOCATE(ELEMENT(IEL1).NODE,SOURCE=NODE1(1:2))                           
            ENDDO
        ENDIF
        
        DO I=1,SELF.NSEMI_SF            
            N2=SELF.SEMI_SF_IPG(I)
            PHYSICALGROUP(N2).ISMODEL=.TRUE.
            IF(PHYSICALGROUP(N2).MAT(1)==0.AND.IA1(1)>0) THEN
                PHYSICALGROUP(N2).MAT=PHYSICALGROUP(IA1(1)).MAT
            ENDIF
            IF(PHYSICALGROUP(N2).MAT(1)==0.AND.IA1(2)>0) THEN
                PHYSICALGROUP(N2).MAT=PHYSICALGROUP(IA1(2)).MAT
            ENDIF  
            IF(PHYSICALGROUP(N2).MAT(1)==0) THEN
                PRINT *,'PLEASE SIGN A MATID TO PHYSICALGROUP(N2) THROUGH "GROUPPARAMETER". N2=',N2
                STOP
            ENDIF 
            PHYSICALGROUP(N2).ET="SEMI_SPHFLOW"
            PHYSICALGROUP(N2).ET_GMSH=1
            PHYSICALGROUP(N2).PROPERTY(1:3)=SELF.DIR_VECTOR(:,I)
            DO J=1,PHYSICALGROUP(N2).NEL
                IEL1=PHYSICALGROUP(N2).ELEMENT(J)
                ELEMENT(IEL1).NNODE=2
                IF(NODE(ELEMENT(IEL1).NODE(1)).N1==0) THEN
                    STOP "GHOST NODE N1 SHOULD BE >0. Error in sub WELLBORE_INITIALIZE."
                ENDIF
                NODE1(1:ELEMENT(IEL1).NNODE)=[NODE(ELEMENT(IEL1).NODE).N1,ELEMENT(IEL1).NODE]
                DEALLOCATE(ELEMENT(IEL1).NODE)
                ALLOCATE(ELEMENT(IEL1).NODE,SOURCE=NODE1(1:2))                           
            ENDDO             
        ENDDO
        
        !BC
        N1=SELF.WELLNODE
        SELF.NQNODE=PHYSICALGROUP(N1).NEL
        N2=1
        IF(SELF.NSPG_FACE>0) N2=1+MAXVAL(PHYSICALGROUP(SELF.SPG_FACE(1:SELF.NSPG_FACE)).NEL)
        IF(.NOT.ALLOCATED(SELF.QNODE)) ALLOCATE(SELF.QNODE(N2,PHYSICALGROUP(N1).NEL))
        SELF.QNODE=-1
        IF(ALLOCATED(IELT1)) DEALLOCATE(IELT1)
        ALLOCATE(IELT1(NEL))        
        DO I=1,PHYSICALGROUP(N1).NEL 
            IEL1=PHYSICALGROUP(N1).ELEMENT(I)
            ELEMENT(IEL1).NODE=NODE(ELEMENT(IEL1).NODE).N1
            !FIND THE WELLBORE_SPGFACE ELEMENT CONNECT TO THE WELLNODE,TO SUM THE WELL Q
            N2=1
            SELF.QNODE(N2,I)=ELEMENT(IEL1).NODE(1)
            IELT1=0

10          DO J=1,SELF.NSPG_FACE
                N3=SELF.SPG_FACE(J)
                DO K=1,PHYSICALGROUP(N3).NEL
                    N4=PHYSICALGROUP(N3).ELEMENT(K)
                    IF(IELT1(N4)/=0) CYCLE
                    IF(ELEMENT(N4).NODE(1)==SELF.QNODE(N2,I)) THEN
                        N2=N2+1
                        SELF.QNODE(N2,I)=ELEMENT(N4).NODE(2)
                        IELT1(N4)=1
                        GOTO 10
                    ELSEIF(ELEMENT(N4).NODE(2)==SELF.QNODE(N2,I)) THEN
                        N2=N2+1
                        SELF.QNODE(N2,I)=ELEMENT(N4).NODE(1)
                        IELT1(N4)=1
                        goto 10
                    ENDIF
                ENDDO
            ENDDO
        ENDDO
        
        IF(SELF.BCTYPE/=1) THEN
            
            NELT_BC=NELT_BC+1
            IF(NELT_BC>SIZE(ELT_BC,DIM=1)) CALL ENLARGE_AR(ELT_BC,10)
            
            ELT_BC(NELT_BC).GROUP=SELF.WELLNODE
            ELT_BC(NELT_BC).NDIM=0
            ELT_BC(NELT_BC).DOF=4
            ELT_BC(NELT_BC).VALUE=SELF.VALUE
            IF(SELF.BCTYPE==0) ELT_BC(NELT_BC).ISWELLCONDITION=1 !自流减压井水头边界，其出水量只出不进
        ELSE            
            NELT_LOAD=NELT_LOAD+1
            IF(NELT_LOAD>SIZE(ELT_LOAD,DIM=1)) CALL ENLARGE_AR(ELT_LOAD,10)
            ELT_LOAD(NELT_LOAD).GROUP=SELF.WELLNODE
            ELT_LOAD(NELT_LOAD).NDIM=0
            ELT_LOAD(NELT_LOAD).DOF=4
            ELT_LOAD(NELT_LOAD).VALUE=SELF.VALUE            
        ENDIF        
    
        DO I=1,SELF.NSPG_FACE
            IF(nelt_spgface+SELF.NSPG_FACE>SIZE(ELT_SPGFACE,DIM=1)) CALL ENLARGE_AR(ELT_SPGFACE,SELF.NSPG_FACE)
            nelt_spgface=nelt_spgface+1
            
            ELT_SPGFACE(NELT_SPGFACE).GROUP=SELF.SPG_FACE(I)
            ELT_SPGFACE(NELT_SPGFACE).NDIM=0
            ELT_SPGFACE(NELT_SPGFACE).DOF=4
            ELT_SPGFACE(NELT_SPGFACE).VALUE=SELF.VALUE            
            ELT_SPGFACE(NELT_SPGFACE).ISWELLCONDITION=1 !SELF.SINK_NODE_SPG_FACE(I)
        ENDDO
        
        IF(ALLOCATED(ISWBE1)) DEALLOCATE(ISWBE1)
        IF(ALLOCATED(IA1)) DEALLOCATE(IA1)
    ENDSUBROUTINE
    
    SUBROUTINE WELLBORE_OUTPUTQNODE(SELF,UNIT)
        CLASS(WELLBORE_TYDEF)::SELF
        INTEGER,INTENT(IN)::UNIT
        INTEGER::I,J,K,N1,N2,N3,N4,INODE1,IEL1,II1,N5,NEL1,imethod1
        
        WRITE(UNIT,10) SELF.NQNODE
        
        DO I=1,SELF.NQNODE
            N1=COUNT(SELF.QNODE(:,I)>0)
            WRITE(UNIT,20) NODE(SELF.QNODE(1:N1,I)).INODE
        ENDDO
        
10      FORMAT("QWELLNODE,NUM=",I4)        
20      FORMAT(<N1>(I7,1X))  
    ENDSUBROUTINE
    
  !  SUBROUTINE SET_ELEMENT_EDGE(THIS)
  !      CLASS(element_type)::THIS
		!INTEGER::I
		!
		!DO I=1,elttype(THIS.ET).NEDGE
		!	
		!ENDDO
  !      
  !  END SUBROUTINE
  !  SUBROUTINE SET_ELEMENT_FACE(THIS)
  !      CLASS(element_type)::THIS
  !      
  !  END SUBROUTINE 
!translate all the characters in term into lowcase character string
    subroutine lowcase(term,iterm)
	    use dflib
	    implicit none
	    integer i,in,nA,nZ,nc,nd
        integer,optional::iterm
	    character(1)::ch
	    character::term*(*)
	
	    term=adjustl(trim(term))
	    nA=ichar('A')
	    nZ=ichar('Z')
	    nd=ichar('A')-ichar('a')
	    in=len_trim(term)
	    do i=1,in
		    ch=term(i:i)
		    nc=ichar(ch)
		    if(nc>=nA.and.nc<=nZ) then
			    term(i:i)=char(nc-nd)
		    end if
	    end do
    end subroutine    
    
   !把字符串中相当的数字字符(包括浮点型)转化为对应的数字
   !如 '123'转为123,'14-10'转为14,13,12,11,10
   !string中转化后的数字以数组ar(n1)返回，其中,n1为字符串中数字的个数:(注　1-3转化后为3个数字：1,2,3)
   !nmax为数组ar的大小,string默认字符长度为512。
   !num_read为要读入数据的个数。
   !unit为文件号
   !每次只读入一个有效行（不以'//'开头的行）
   !每行后面以'//'开始的后面的字符是无效的。
   subroutine  strtoint(unit,ar,nmax,n1,num_read,set,maxset,nset,ef1)
	    implicit none
	    logical::tof1,tof2
	    integer::i,j,k,strl,ns,ne,n1,n2,n3,n4,step,nmax,& 
			num_read,unit,n5,nsubs,maxset,nset,ef
        integer,optional::ef1
	    real(8)::ar(nmax),t1
        character(256)::set(maxset)
	  
        character(20000)::string
	    character(512)::substring(1000)
	    character(16)::legalC,SC
      

        LegalC='0123456789.-+eE*'
        sc=',; ()'//char(9)

        n1=0
        nset=0
        ar=0
        
	  do while(.true.)
		 read(unit,'(a)',iostat=ef) string
		 if(ef<0) then
             if(present(ef1))  then
                 ef1=ef
             else
			    print *, 'file ended unexpected. sub strtoint()'
			    stop
            endif
		 end if

		 string=adjustL(string)
		 strL=len_trim(string)
		 
		do i=1,strL !remove 'Tab'
			if(string(i:i)/=char(9)) exit
		end do
		string=string(i:strL)
		string=adjustl(string)
		strL=len_trim(string)
		if(strL==0) cycle
        !call str_replace(string,'(',' ')
        !call str_replace(string,')',' ')
		 if(string(1:2)/='//'.and.string(1:1)/='#') then
			
			!每行后面以'/'开始的后面的字符是无效的。
			if(index(string,'//')/=0) then
				strL=index(string,'//')-1
				string=string(1:strL)
				strL=len_trim(string)
			end if

			nsubs=0
			n5=1
			do i=2,strL+1
				if(index(sc,string(i:i))/=0.and.index(sc,string(i-1:i-1))==0) then
					nsubs=nsubs+1					
					substring(nsubs)=string(n5:i-1)					
				end if
				if(index(sc,string(i:i))/=0) n5=i+1
			end do
			
			do i=1, nsubs
				substring(i)=adjustl(substring(i))				
				n2=len_trim(substring(i))
				!the first character should not be a number if the substring is a set.
				if(index('0123456789-+.', substring(i)(1:1))==0) then
					!set
					nset=nset+1
					set(nset)=substring(i)
					cycle
				end if
				n3=index(substring(i),'-')
				n4=index(substring(i),'*')
				tof1=.false.
				if(n3>1) then
				    tof1=(substring(i)(n3-1:n3-1)/='e'.and.substring(i)(n3-1:n3-1)/='E')
				end if
				if(tof1) then !处理类似于'1-5'这样的形式的读入数据
					read(substring(i)(1:n3-1),'(i8)') ns
					read(substring(i)(n3+1:n2),'(i8)') ne
					if(ns>ne) then
						step=-1
					else
						step=1
					end if
					do k=ns,ne,step
						n1=n1+1
						ar(n1)=k
					end do				     	
				else
				     tof2=.false.
				     if(n4>1) then
				             tof2=(substring(i)(n4-1:n4-1)/='e'.and.substring(i)(n4-1:n4-1)/='E')
				     end if
					if(tof2) then !处理类似于'1*5'(表示5个1)这样的形式的读入数据
						read(substring(i)(1:n4-1),*) t1
						read(substring(i)(n4+1:n2),'(i8)') ne
						ar((n1+1):(n1+ne))=t1
						n1=n1+ne
					else
						n1=n1+1
						read(substring(i),*) ar(n1)
					end if	
				end if			
			end do
		 else
			cycle
		 end if
		
		 if(n1<=num_read) then
		    exit
		 else
		    if(n1>num_read)  print *, 'error!nt2>num_read. i=',n1
		 end if
	
      end do
    

   end subroutine

    subroutine str_replace(str,osubstr,nsubstr)
    implicit none
    

    ! replace  all occurrences of substring 'osubstr' with 'nsubstr'  from string 'str' .
    ! no replace for "space"

    character(len=*):: str,osubstr,nsubstr
    integer::lensubstr
    integer::ipos
    !osubstr=adjustl(osubstr)
    lensubstr=len_trim(osubstr)
    if(lensubstr==0) return
    do
       ipos=index(str,osubstr(1:lensubstr))
       if(ipos == 0) exit
       !if(ipos == 1) then
       !   str=str(lensubstr+1:)
       !else
       !   str=str(:ipos-1)//str(ipos+lensubstr:)
       !end if
       str=str(:ipos-1)//trim(nsubstr)//trim(str(ipos+lensubstr:))
       !if(ipos == 1) then
       !   str=str(lensubstr+1:)
       !else
       !   str=str(:ipos-1)//str(ipos+lensubstr:)
       !end if
   
    end do   
    return

    end subroutine 
    
    INTEGER FUNCTION INCOUNT(N)
        IMPLICIT NONE
        INTEGER,INTENT(IN)::N
        REAL(8)::T1
        INTEGER::I

        T1=ABS(N)
        INCOUNT=INT(LOG10(T1))+1
	    IF(N<0) INCOUNT=INCOUNT+1
    

    END FUNCTION    
    
    
end module
